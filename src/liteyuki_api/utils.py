import os
import traceback
from typing import Tuple, Dict, List, Iterable

import nonebot
import requests
from aiohttp.client_reqrep import ClientResponse
from requests import Response
import aiohttp
from .canvas import Text
from .config import config_data

generate_signature = "Generated by LiteyukiBot %s" % config_data["version_name"]


def clamp(x, _min, _max):
    if x < _min:
        return _min
    elif _min <= x <= _max:
        return x
    else:
        return _max


def average(_iterable: Iterable) -> float:
    total = sum(_iterable)
    return total / len(_iterable)


def download_file(url, file, chunk_size=1024, detect=False):
    """
    :param url: 链接
    :param file: 文件路径
    :param chunk_size:
    :param detect: 检测到本地有就不下载
    :return:
    """
    if os.path.exists(file) and detect:
        return 0
    try:
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.66 Safari/537.36'}
        if not os.path.exists(os.path.dirname(file)):
            os.makedirs(os.path.dirname(file))
        response_data_file = requests.get(url, stream=True, headers=headers)
        with open(file, 'wb') as f:
            for chunk in response_data_file.iter_content(chunk_size=chunk_size):
                if chunk:
                    f.write(chunk)
        nonebot.logger.info("下载成功： %s" % url)
    except BaseException as e:
        nonebot.logger.warning("下载失败: %s\n%s" % (url, traceback.format_exception(e)))


def simple_request_get(url, **kwargs) -> Response:
    """同步简易请求函数"""
    resp = requests.get(url, **kwargs)
    return resp

async def simple_request_async(method, url, **kwargs):
    """异步简易请求函数"""
    async with aiohttp.request(method, url, **kwargs) as resp:
        return resp


def size_text(byte: int, dec: int = 2) -> str:
    """
    :param byte:
    :param dec: 浮点位数
    :return:
    """
    """1024转为1kb"""
    if (size := byte / 1024 ** 4) > 1:
        unit = "TB"
    elif (size := byte / 1024 ** 3) > 1:
        unit = "GB"
    elif (size := byte / 1024 ** 2) > 1:
        unit = "MB"
    elif (size := byte / 1024 ** 1) > 1:
        unit = "KB"
    else:
        unit = "B"
    return "%s%s" % (round(size, dec), unit)


def time_format_list(seconds: int) -> list:
    times = []
    secs = [31104000, 2592000, 86400, 3600, 60, 1]
    for sec in secs:
        times.append(seconds // sec)
        seconds = seconds % sec
    return times


def time_to_cn_by_sec(seconds) -> str:
    """
    时长文本带汉字单位： 3年4个月5天12小时32分12秒

    :param seconds
    :return:
    """
    time_list = time_format_list(seconds)
    text = ""
    show = False
    units = [
        "年", "个月", "日", "时", "分", "秒"
    ]
    for value, unit in zip(time_list, units):
        if value > 0:
            show = True
        if show:
            text += "%s%s" % (value, unit)
    return text


def time_to_hms_by_sec(seconds) -> str:
    """
    时长文本仅到时分秒： 23:23:23

    :param seconds
    :return:
    """
    time_list = time_format_list(seconds)
    text = ""
    show = True
    units = [
        ":", ":", ""
    ]
    time_list[3] += time_list[0] * 31536000 + time_list[1] * 2592000 + time_list[2] * 86400
    for value, unit in zip(time_list[3:], units):
        if value > 0:
            show = True
        if show:
            text += "%s%s" % (value, unit)
    return text


class Command:

    @staticmethod
    def get_keywords(old_dict: dict, keywords: dict) -> dict:
        """
        :param keywords:
        :param old_dict:
        :return:

        提取旧字典中设定键合成新字典
        """
        new = dict()
        for key in keywords:
            new[key] = old_dict.get(key, keywords[key])
        return new

    @staticmethod
    def formatToCommand(cmd: str, sep: str = " ", kw=True) -> Tuple[Tuple, Dict]:
        """
        :param kw: 将有等号的词语分出
        :param sep: 分隔符,默认空格
        :param cmd: "arg1 arg2 para1=value1 para2=value2"
        :return:

        命令参数处理
        自动cq去义
        "%20"表示空格
        """
        cmd = Command.escape(cmd, blank=False)
        cmd_list = cmd.strip().split(sep)
        args = []
        keywords = {}
        for arg in cmd_list:
            arg = arg.replace("%20", " ")
            if "=" in arg and kw:
                keywords[arg.split("=")[0]] = "=".join(arg.split("=")[1:])
            else:
                args.append(arg)
        args = tuple(args)
        return args, keywords

    @staticmethod
    def formatToString(*args, **keywords) -> str:

        """
        :param args:
        :param keywords:
        :return:
        escape会将空格转为%20，默认False不转，会将空格转为%20
        """

        string = ""
        for arg in args:
            string += Command.escape(arg) + " "
        kw_item = keywords.items()
        for item in kw_item:
            kw = "%s=%s" % (item[0], item[1])

            string += Command.escape(kw) + " "
        return string[:-1]

    @staticmethod
    def escape(text: str, blank=True) -> str:
        """
        CQ码去义

        :param text:
        :param blank: 转义%20为空格
        :return:
        """
        escape_data = {
            "&amp;": "&",
            "&#91;": "[",
            "&#93;": "]",
            "&#44;": ","
        }
        for esd in escape_data.items():
            text = text.replace(esd[0], esd[1])
        return text.replace("%20", " " if blank else "%20")
